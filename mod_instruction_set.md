# Этот вспомогательный файл по диалекту Coco языка Ассемблера создан студентом 24940 группы  Мехатроники и Робототехники ;) "Спасибо" сюда 👉 [github](https://github.com/McAshesha) и [telegram](https://t.me/McAshesha)

## 🚀 ✅ КОМАНДЫ РАБОТЫ С РЕГИСТРАМИ

- `ldi <to_reg>, <smth>` — (LoaD Immediate) записать что-то (`<smth>`) в регистр `<to_reg>` 📝
- `ld <from>, <to>` — (LoaD) считать из памяти 💾 (адрес в регистре `<from>`) и записать в регистр `<to>` 📥
- `st <to>, <from>` — (STore) записать в память 💾 (адрес в регистре `<to>`) данные из регистра `<from>` 📤
- `move <from>, <to>` — (move) скопировать значение из регистра `<from>` в регистр `<to>` 🔄

### 📖 Примеры:

- `ldi r0, a` — аналог на C: `r0 = &a;` (узнаём адрес в памяти, где лежит `a`) 🗺️
- `ld r0, r1` — аналог на C:
  ```c
  r0 = &a;
  r1 = scanf("%d", r0);
  ```
  Или можно так:
  ```c
  r1 = scanf("%d", &a);
  ```
- `st r0, r1` — аналог на C: `int *r0 = r1;` (по адресу `r0` записываем число `r1`) ✍️
- `move r0, r1` — аналог на C: `r1 = r0` 🔁

## ✅ ➕ ARITHMETIC

- `clr rn` — (CLeaR) очистка регистра (аналог на C: `rn = 0`) 🗑️
- `add rn, rm` — (ADD) аналог на C: `rm = rn + rm` ➕
- `sub rn, rm` — (SUBtract) аналог на C: `rm = rn - rm` ➖
- `addc rn, rm` — (ADD + C) то же, что и `add`, но добавляет значение бита `C` (бит переноса), оставшееся после предшествующей операции 🏳️
- `inc rn` — (INCrement) аналог на C: `rn++;` ⬆️
- `dec rn` — (DECrement) аналог на C: `rn--;` ⬇️
- `neg rn` — (NEGative) аналог на C: `rn = -rn;` 🔄
- `shra rn` — (SHift Right Arithmetic) аналог на C: `rn >> 1` (битовый сдвиг на 1 вправо; то же что и целочисленное деление на 2). **Важно**: бит знака сохраняется. Пример:
  ```
  shra 0b1001_0101 >>> 0b1100_1010  // "_" для удобства чтения
  ```
- `shla rn` — (SHift Left Arithmetic) аналог на C: `rn << 1` (битовый сдвиг на 1 влево; то же что и умножение на 2). **C-bit** = самый левый бит переданного числа. 🚀
- `shr rn` — то же что и `shra`, но бит знака не сохраняется (утверждение основано на парочке опытов) 🔎
- `shl rn` — то же что и `shla`, вроде (но подсвечивается фиолетовым, как макрос) 💡
- `rol rn` — (ROtate Left) тот же `shla rn`, но самый правый бит станет не 0, а возьмёт значение из самого левого бита (так же как и бит `C` из `CVZN`) 🔄
- `cmp rn, rm` — (CoMPare) мы просто имеем число `rn - rm`, но биты `CVZN` меняются. Их изменение нас и интересует (правда, я не знаю как их считывать...) ⚖️

## ✅ 🧮 LOGICAL (bitwise / побитовое)

- `and rn, rm` — аналог на C: `rm = rn & rm` (побитовая конъюнкция [AND]) 🔗
- `or rn, rm` — аналог на C: `rm = rn | rm` (побитовая дизъюнкция [OR]) 🔘
- `xor rn, rm` — аналог на C: `rm = rn ^ rm` (побитовая исключающая дизъюнкция [XOR]) ❌
- `not rn` — аналог на C: `rn = ~rn` (побитовое отрицание [NOT]). Пример: `~5 = -6` (происходит смещение) 🚫

## ✅ 📦 ПЕРЕМЕННЫЕ и выделение памяти

- `a: dc 23` — в ячейку памяти (1 байт) записать число `23` 🗄️
  - Как найти ячейку: `ldi rn, a` (в регистр `rn` запишем адрес памяти с этим числом) 📍
- `b: ds 1` — зарезервировать 1 байт памяти 📦
  - Как найти ячейку: `ldi rn, b` 🔎
- `c: ds n` — зарезервировать `n` байт памяти 📦📦📦
  - Как найти ячейку: `ldi rn, c` 🧭

---

### 📚 Словарь:

- `rn` — какой-то регистр 📄
- `offset` — смещение ↔️
- `PC` — адрес в памяти, команда которая будет выполняться 🖥️
- `SP` — адрес памяти, откуда `pop` 🗂️
- `<const>` — какая-то метка (`label`), например, `mult` 🏷️
- `!` — `not` (отрицание переменной) ❗

---

### ⚙️ Условия для `is` / `stays` / `until`:

| Условие   | Флаг         | Интерпретация                                                          |
|-----------|--------------|------------------------------------------------------------------------|
| `eq`/`z`  | `Z`          | equal, equal zero (`rj == ri` / `rn == 0`) ✅
| `ne`/`nz` | `!Z`         | not equal, not zero (`ri != rj`, `rn != 0`) ❌
| `hs`/`cs` | `C`          | unsigned higher or same (беззнаковое `>=`) 📈
| `lo`/`cc` | `!C`         | unsigned lower (беззнаковое `<`, например, `17 < 193` выполнится блок `is`) 📉
| `hi`      | `(C & !Z)`   | unsigned higher (беззнаковое `>`) 🔼
| `ls`      | `(!C or Z)`  | unsigned lower or same (беззнаковое `<=`) 🔽
| `mi`      | `N`          | negative (если число `< 0`, число ∈ `[-128; -1]`) ➖
| `pl`      | `!N`         | positive or zero (если число `>= 0`, число ∈ `[0; 127]`) ➕
| `vs`      | `V`          | overflow is set (если при сложении двух положительных чисел получилось отрицательное, или наоборот — сложили два отрицательных числа и получили положительное) 🌋
| `vc`      | `!V`         | overflow is clear (сложили отрицательные числа и получили отрицательное, или сложили два положительных числа и получилось положительное) 🌈
| `ge`      | `(N & V) or (!N & !V)` | greater than or equal (знаковое `>=`) 📈
| `lt`      | `(N & !V) or (!N & V)` | less than (знаковое `<`) 📉
| `gt`      | `(!Z & N & V) or (!Z & !N & !V)` | greater than (знаковое `>`) 🔼
| `le`      | `(Z or N & !V) or (!N & V)` | less than or equal (знаковое `<=`) 🔽

---

### 🔄 `if`, `while`, `do-until`

Условия для `is`, `stays` и `until`выше.

#### Структура:

**if**

- Подготовительные действия, примеры: `tst rn` / `cmp ri, rj` (по факту `sub ri, rj`, но `rj` не перезапишется)

```assembly
if
  # подготовительные действия
is <условие>
  # do something 🛠️
fi  # закрыть if
```

**while**

- Подготовительные действия, примеры: `tst rn` / `cmp ri, rj`

```assembly
while
  # подготовительные действия
stays <условие>  # тот же `is`, но для `while`
  # do something 🔁
wend  # закрыть while
```

**do-until**

```assembly
do
  # do something 🔄
until <условие>  # условия такие же, как для `is` и `stays`
```

**CONTINUE** и **BREAK** работают также как в C:

- `continue` — переходит к следующей итерации цикла ⏩
- `break` — выходит из цикла и выполняет следующую команду ⏹️

---

### 📚 СТЕК

Стек работает с конца: сначала значение кладётся в ячейку `0xFF`, затем — в `0xFE`, после — `0xFD` и так далее. 📥

- `push rn` — аналог на C:
  ```c
  SP--;
  *SP = rn;
  ```
- `pop rn` — аналог на C:
  ```c
  rn = *SP;
  SP++;
  ```

---

### 🔧 Другие команды

- `asect <число от 0 до 255>` — "говорит" компилятору, с какого адреса начать вставлять код программы. Например, при `asect 0x00` компилятор будет вставлять код с начала. 🏁
- `rsect <const>` — объявляет начало подпрограммы в отдельном файле.

  **Пример:**

  _В отдельном файле_:

  ```assembly
  rsect mul
  mul>  # именно "mul>" а не "mul:", так как это для `rsect`
    push r2  # save r2 💾
    ldi r2, 0  # clr r2 🗑️

    inc r1  # иначе 1 итерации не хватает ⬆️
    while
      dec r1  # ⬇️
    stays ne
      add r0, r2  # ➕
    wend
    move r2, r0  # result will be in r0 (r0 = r2) 🔁
    pop r2  # restore r2 💾

    rts  # go back 🔙
  ```

  _В главном файле_ считаем `-3x + 7`:

  ```assembly
  asect 0  # 🏁
  mul: ext  # объявляем метку внешней (declare `mul` as an external label) 🌐
  ldi r0, x  # \ 📝
  ld r0, r0  # / r0 = x
  ldi r1, -3  # r1 = -3 ➖
  jsr mul  # goto mul, r0 = r0 * r1,  r0 = -3x 🚀
  ldi r1, 7  # r1 = 7 ➕
  add r1, r0  # r0 += r1,  r0 = -3x + 7 ➕
  halt  # 🛑
  x: dc <число>  # 📥
  end  # 🔚
  ```

- `tplate <name>` — относительная адресация (пересчет, добавление). 📖

---

### 🛠️ Дополнительные команды работы со стеком

- `addsp n` — `SP += n` ➕
- `ldsa rn, offset` — `rn = SP + offset` 📐
- `ldsp rn` — `rn = SP` 🗂️
- `stsp rn` — не очень разобрался, что-то очень странное. 🤔

  **Пример:**

  ```assembly
  stsp r0  # аналог на C: *SP = r1 📝
  stsp r1  # аналог на C: *SP = r0 📝
  ```

---

### 🔄 SUBROUTINES (подпрограммы)

- `jsr <const>` — что-то похожее на `goto`, также кладёт в стек, куда вернуться. 🧭
  - При вызове `jsr`:
    ```assembly
    SP = SP - 1
    *SP = PC
    PC = <const>
    ```
- `rts` — без аргументов.
  - При вызове:
    ```assembly
    PC = *SP
    SP++
    ```
    Или коротко: `PC = pop(stack)`
- `jsrr rn` — аналог `jsr`, но вместо `<const>` используется значение из регистра.

**Пример кода:**

```assembly
# main
ldi r0, 5  # r0 = 5 📝
ldi r1, 4  # r1 = 4 📝
jsr mult  # "goto mult" 🚀
# после этого r0 = r0 * r1

mult:
  push r2  # save r2 💾
  ldi r2, 0  # clr r2 🗑️

  inc r1  # иначе 1 итерации не хватает ⬆️
  while
    dec r1  # ⬇️
  stays ne
    add r0, r2  # r2 = r0 + r2 ➕
  wend
  move r2, r0  # result will be in r0 (r0 = r2) 🔁
  pop r2  # restore r2 💾

  rts  # go back, продолжить выполнять команды после jsr mult 🔙
# конец примера
```

---